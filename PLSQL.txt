/* Two Types of Blocks in PLSQL
1. Anonymous Block
DECLARE
BEGIN
EXCEPTION
END;
/

2. Named Block ---- Stored as an Object in DB.

PROCEDURE
FUNCTION
PACKAGE
TRIGGER
*/

SET SERVEROUTPUT ON;
DECLARE  
    variable varchar2(10):='hi';
    num1 number(20,1):=&num1;
    num2 number(20,1):=&num2;
    add number(30,1);
BEGIN
    add:=num1+num2;
    dbms_output.put_line(variable);
    dbms_output.put_line('Addition value of '||num1||' and '||num2||' is '||add);
    
end;
/
--------------------------------------------Using select statement inside PLSQL Block using Variables---------------------------------------------------
SET SERVEROUTPUT ON;
Declare
    va_dep varchar(20);
Begin
    select department into va_1 from employee where emp_id='4';             --single variable
    dbms_output.put_line('department is '|| va_dep);
end;
/

SET SERVEROUTPUT ON;
Declare
    va_fname varchar(20);
    va_sal number(10);
Begin
    select first_name,salary into va_fname,va_sal from employee where emp_id='5';             --multi variable
    dbms_output.put_line('Employees First name is '||va_fname||' and its Salary is ' ||va_sal );
end;
/

--------------------------------------------Using DML statement inside PLSQL Block---------------------------------------------------
---1. INSERT

SET SERVEROUTPUT ON;
Declare
Begin
    insert into customer1 (cust_id, first_name, last_name,email,phone,city) 
    values (1, 'Amit', 'Shah', 'amit.shah@email.com', '9876543210', 'Mumbai');
    commit;
End;
/
--Insert values from existing customer table
SET SERVEROUTPUT ON;
Declare
Begin
    insert into customer1 
    select * from customer where cust_id != 1;
    commit;
End;
/

select * from customer;
select * from customer1;

---2. UPDATE
Begin
    update customer1 set first_name='Tanish' where cust_id=1;
End;
/

---3. DELETE
Begin
    delete from customer1 where cust_id=10;
    commit;
End;
/

----------------------------------------------Using %Type and %Rowtype inside PLSQL Block DDL as well-----------------------------------------------------------
create table cust 
(
    cust_id number(10) primary key,
    cust_name varchar2(40),
    dob date,
    mobile_n number(10),
    city varchar2(20)
    );
    
insert into cust (cust_id,cust_name,dob,mobile_n,city) values (1001, 'Arun', to_date('12/09/1985', 'mm/dd/yyyy'), 9090909090, 'Chennai');
insert into cust (cust_id,cust_name,dob,mobile_n,city) values (1002, 'John', to_date('01/09/1987', 'mm/dd/yyyy'), 9090909091, 'Pune');
insert into cust (cust_id,cust_name,dob,mobile_n,city) values (1003, 'Babu', to_date('06/23/1995', 'mm/dd/yyyy'), 9090909092, 'Hyderabad');
commit;
select * from cust;
---==============================================================================
set serveroutput on;
Declare
    var_mob_no number(10);
Begin
    select mobile_n into var_mob_no from cust where cust_id=1002;
    dbms_output.put_line('The mobile number is '|| var_mob_no);
End;
/
---==============================================================================
----Now we have to change the datatype of mobile_n from number to varchar2

alter table cust modify mobile_n varchar(20);
ORA-01439: column to be modified must be empty to change datatype

---So  Step 1: Add new VARCHAR2 column
alter table cust add mobile_new varchar(20);
---Step 2: Copy data (implicit conversion by Oracle)
update cust set mobile_new=mobile_n;
---Step 3: Drop the old NUMBER column
alter table cust drop column mobile_n;
---Step 4: Add '+91-" in front of all numbers.
update cust set mobile_new = '+91-'||mobile_new;
---Step 5: Rename new column to old column
alter table cust rename column mobile_new to mobile_n;
commit;

---But Now if try to run the Our PLSQL code again it will give error because our datatype inside our code is number but new type is varchar2.
---ORA-06502: PL/SQL: numeric or value error: character to number conversion error
---So we can use the %Type and %Rowtype so no need to mention the datatype to the variable for select it will directly refer the datatype from the table itself.

set serveroutput on;
Declare
var_mob_no cust.mobile_n%type;           ---For one specific coloumn use tablename.columnname%type so no matter how many times we change the datatype of column.
Begin
select mobile_n into var_mob_no from cust where cust_id=1002;
dbms_output.put_line('The mobile no is '||var_mob_no);
End;
/

set serveroutput on;
Declare
var_all_columns cust%rowtype; --One common variable to store all table data.
Begin
select * into var_all_columns from cust where cust_id=1002;     ---For more than one columns use tablename.%rowtype
dbms_output.put_line('The customer name is '||var_all_columns.cust_name);
dbms_output.put_line('The customer dob is '||var_all_columns.dob);
End;
/
-----------------------------------------------CONTROL/CONDITIONAL STATEMENTS-------------------------------------------------------------
--1. IF STATEMENTS
set serveroutput on;
declare
a boolean:=&a;
begin
    if a = true then
        dbms_output.put_line('a is true');
    elsif a is null then
        dbms_output.put_line('please give either true or false');
    else
        dbms_output.put_line('a is false');
    end if;
end;
/

--2. CASE
desc employee;
select * from employee;

set serveroutput on;
Declare
v_empid number(6):=&v_empid;
v_salary number(10);
v_fname varchar2(20);
Begin
    select salary, first_name into v_salary, v_fname from employee where emp_id=v_empid;
case
when v_salary > 70000 then
    dbms_output.put_line(v_fname||' has best salary Amount = '||v_salary); 
when v_salary >= 50000 and v_salary <= 70000 then
    dbms_output.put_line(v_fname||' has good salary Amount = '||v_salary);
when v_salary >= 40000 and v_salary < 50000 then
    dbms_output.put_line(v_fname||' has average salary Amount = '||v_salary);
else 
    dbms_output.put_line(v_fname||' has low salary Amount = '||v_salary);
end case;
End;
/
--NOTE IF WE WANT TO DISPLAY A COLUMN using SELECT GO WITH CASE STATEMENT

select * from cust;

select cust_id, cust_name, dob, city, mobile_n, 
case 
when initcap(city)= 'Chennai' then '+C-'||mobile_n
when initcap(city)= 'Pune' then '+P-'||mobile_n
when initcap(city)= 'Hyderabad' then '+H-'||mobile_n
else mobile_n
end as new_mob_no from cust;
    
-----------------------------------------------LOOPS-------------------------------------------------------------

--1. LOOP

declare 
c number(10):=0;
begin
loop
c:=c+2;
dbms_output.put_line(c);
exit when c>=10;
end loop;
end;
/

--2. WHILE LOOP

declare
c number(10):=0;
begin
while(c<5)
loop
dbms_output.put_line(c);
c:=c+1;
end loop;
end;
/

--3. FOR LOOP

declare
c number(10);
begin
for c in 1..5         --To print in reverse [for c in reverse 1..5]
loop
dbms_output.put_line(c);
end loop;
end;
/
--=========================================================== CURSOR ========================================================================
/*
✅ What is Cursor?

Cursor is defined as a private work area where the sql statement (SELECT and DML) is executed.
A cursor is a mechanism that lets you handle multiple rows returned by a query in PL/SQL.
You use a cursor when your SQL query returns multiple rows and you want to process them one by one. 
If you try to do it without cursor you may get error => ORA-01422: exact fetch returns more than requested number of rows
Without cursor you can fetch single row.

Two types:-

1. Implicit Cursor (Automatic)
  ----------------------------
Created automatically by Oracle for every session and managed by oracle whenever you run a DML and SELECT statement.
eg:-    SELECT * INTO v_name FROM employees WHERE emp_id = 10;
Oracle internally creates an implicit cursor to execute this. We donnot have control over this cursor but we can get information from its attributes.

+++Cursor Attributes (Common to Both)
Both implicit and explicit cursors have:

Attribute	Type        Meaning
%FOUND      Boolean   TRUE if last fetch/operation returned a row
%NOTFOUND	Boolean   TRUE if last operation returned no row
%ROWCOUNT	Number    Number of rows processed so far
%ISOPEN 	Boolean   TRUE if cursor is open

%ISOPEN is always FALSE
Because Oracle automatically opens and closes it in a single step
You cannot manually open or close it.
*/

--To see attributes of implicit cursor
desc cust;
select * from cust;
set serveroutput on;
Begin
update cust set mobile_n='+91-'||mobile_n where cust_id=&cust_id;
if sql%notfound then
    dbms_output.put_line('No data found');
else 
    dbms_output.put_line(sql%rowcount||' - rows updated');
end if;
End;
/

/*
2. Explicit Cursor (User Defined)
  --------------------------------
  An explicit cursor is a cursor that you create manually in PL/SQL to handle and process multiple rows returned by a query.
  Oracle does not automatically manage it — you control the OPEN, FETCH, and CLOSE steps.
  
*/
--NAMED EXPLICIT CURSOR
---For Bulk select
set serveroutput on;
Declare
    v_salary employee.salary%type;
    v_fname employee.first_name%type;
    cursor c1 is select salary, first_name from employee order by salary desc;
Begin
    open c1;
    loop
        fetch c1 into v_salary,v_fname;
        exit when (c1%notfound) or (c1%rowcount>5);
        dbms_output.put_line(v_fname||' - '||v_salary);
    end loop;
    dbms_output.put_line('');
    dbms_output.put_line('Total Rows :- '||c1%rowcount);
    close c1;
End;
/

--FOR EXPLICIT CURSOR
---Here we dont need to declare variable (a composite variable will handle it ) and open or close cursor, FOR will handle it.

set serveroutput on;
Declare
    cursor c2 is select last_name, salary from employee;
Begin
    for i in c2         -- i is composite variable.
    loop
    dbms_output.put_line(i.last_name||' has '||'this much '||i.salary);
    end loop;
End;
/

--PARAMETER EXPLICIT CURSOR
---A parameterized cursor is a cursor that accepts parameters when opened. To filter data dynamically to avoid hardcoded WHERE conditions and to
---reuse the same cursor for different values.
desc engineer;
select * from engineer;


set serveroutput on;
Declare
    cursor c3(e_branchid number) is select name, branch, salary from engineer where branch_id=e_branchid;
    e_name varchar2(20);
    e_branch varchar2(20);
    e_salary number(10,2);
Begin
    open c3(102);
    loop
    fetch c3 into e_name,e_branch,e_salary;
    exit when c3%notfound;
    dbms_output.put_line('The name is '||e_name||' - '||e_branch||' earns '||e_salary); 
    end loop;
    close c3;
End;
/

/*
REF CURSOR
Ref cursor is a datatype that holds a cursor value in thesame way a VARCHAR2 holds a string value. 
It is a pointer that points to the result of a query. “REF CURSOR is a pointer to a query result that allows dynamic queries and is mainly used 
to return result sets to applications.”
Two types of REF CURSOR:
    Strong REF CURSOR → return type is fixed (must match a table or rowtype).
    Weak REF CURSOR → no fixed return type (can return any query).
Most developers use weak REF CURSOR.
*/

-- i. Weak REF CURSOR → no fixed return type (can return any query).
set serveroutput on;
Declare
    type ref_cursor is REF CURSOR;
    rc_employee_data ref_cursor;
    e_name varchar2(20);
    v_lname varchar(20);
Begin
dbms_output.put_line('----- Engineer Table -----');
    open rc_employee_data for select name from engineer;
    loop
    fetch rc_employee_data into e_name;
    exit when rc_employee_data%notfound;
    dbms_output.put_line(e_name);
    end loop;
    close rc_employee_data;
dbms_output.put_line('----- Employee Table -----');
    open rc_employee_data for select last_name from employee;
    loop
    fetch rc_employee_data into v_lname;
    exit when rc_employee_data%notfound;
    dbms_output.put_line(v_lname);
    end loop;
    close rc_employee_data;
dbms_output.put_line('----- End -----');
End;
/

--- ii. Strong REF CURSOR → return type is fixed (must match a table or rowtype).

set serveroutput on;
Declare
type ref_cursor is REF CURSOR return employee%rowtype;
rc_employee_list ref_cursor;
e_allrecord employee%rowtype;

Begin
    open rc_employee_list for select * from employee;
    loop
    fetch rc_employee_list into e_allrecord;
    exit when rc_employee_list%notfound;
    dbms_output.put_line('The First name is - '||e_allrecord.first_name);
    dbms_output.put_line(e_allrecord.first_name||' s hire date is - '||e_allrecord.hire_date);
    end loop;
    close rc_employee_list;
End;
/


/*
✅ What is a Stored Procedure?

A Stored Procedure is a pre-compiled PL/SQL program stored in the database.
It performs a specific task (like inserting data, updating records, calculations, etc.)

Think of it like a function in programming, but stored inside the database.
*/
-- 1. Non parameterized
set serveroutput on;
Create or replace procedure proc_1
as
Begin
    dbms_output.put_line('Welcome to PLSQL Session');
End;

exec proc_1;

--To drop
drop procedure proc_1;


-- 2. Parameterized
/*
Types of Parameterized Procedures in PL/SQL
PL/SQL procedures support three parameter modes:
*/
--- A.️ IN parameter
--- Passes value into the procedure, Procedure cannot modify the value (read-only), Most commonly used.
set serveroutput on;
Create or replace procedure proc_2 (p_vid in number) 
as
Begin
    dbms_output.put_line('ID = '||p_vid);
End;

exec proc_2(10);
-- or use a PLSQL Block to execute.
Begin
    proc_2(10);
End;
/

--- B. OUT parameter
--- Procedure returns a value back to the caller, Works like a "return variable", Must be assigned inside the procedure.

set serveroutput on;
Create or replace procedure proc_3 (p_name out varchar2)
as
Begin
    p_name:= 'GAWKAR';
End;

--To execute this we need a PLSQL anonymous Block and declare a new string variable.
Declare
    v_name varchar(20);
Begin
    proc_3(v_name);
    dbms_output.put_line('The name is '||v_name||', SUYOG '||v_name);
End;
/

--- C. IN OUT parameter
--- Sends a value inside the procedure, Returns a (possibly modified) value back Useful when you want read+write access.

Create or replace procedure proc_4 (x in out number)
as
Begin
    x:=x*5;
End;

Declare 
    x number(10);
Begin
    x:=4;
    proc_4(x);
    dbms_output.put_line('Value of x is '||x);
End;
/

--- Parameterized Procedure with Cursor.
select * from engineer;
set serveroutput on;
Create or replace procedure get_engineers(in_branch_id IN engineer.branch_id%type)
as
v_name varchar(20);
v_salary number(10);
v_branch varchar(20); 
cursor c1 is select name, salary, branch into v_name, v_salary, v_branch from engineer where branch_id=in_branch_id order by salary desc;
Begin
    Open c1;
    loop
    fetch c1 into v_name,v_salary,v_branch;
    exit when c1%notfound;
    dbms_output.put_line('Name is '||v_name||' Branch is '||v_branch||' and Salary is '||v_salary);
    end loop;
    close c1;
End;


exec get_engineers(105);


/*
✅ What is a Function?
A function is a named PLSQL block which is similar to a procedure. Main difference between both of them is that a function always retuens a value whereas
a procedure may or may not return a value.
A function is a sub program that returns a value when called.
Functions can return more than one value  via OUT parameter. Functions can accept default values.
*/
--- 1. FUNCTION Ex 1
select * from engineer;
select branch, count(*) from engineer group by branch;
set serveroutput on;
Create or replace function salary_hike(p_eng_id IN number)
return number
as
v_dept engineer.branch%type;
v_salary engineer.salary%type;
v_raise number(10,2);
v_newsal number(10,2);
Begin
    select Branch, Salary into v_dept, v_salary from engineer where eng_id=p_eng_id;
    case
    when v_dept='Automobile' then 
    if (v_salary<55000) then v_raise:=0.50;
    elsif (v_salary>55000) then v_raise:=1.00;
    else v_raise:=0; end if;
    when v_dept='Mechanical' then
    if (v_salary<46000) then v_raise:=0.30;
    else v_raise:=0; end if;
    when v_dept='Computer' then
    if (v_salary<60000) then v_raise:=0.05;
    else v_raise:=0; end if;
    else v_raise:=0.10;
    end case;
    if v_raise>0
    then 
    v_newsal:= v_salary + (v_salary*v_raise);
    else
    v_newsal:= v_salary;
    end if;
    return v_newsal;
End;

select eng_id, name, branch,salary, salary_hike(eng_id) New_salary from engineer order by New_salary desc;
select eng_id, name, branch,salary, salary_hike(eng_id) New_salary from engineer where name='Suyog';

--- 2. FUNCTION Ex 2

create table employee_info
( EMP_ID number(5) primary key, FIRST_NAME varchar2(20), LAST_NAME varchar2(20));
desc employee_info;
insert into employee_info values (10, 'RAKESH', 'SHARMA');
insert into employee_info values (20, 'JOHN', 'PAUL');

create table emp_address_details
(EMP_ADDRESS_ID number(5) primary key, EMP_ID number(5) references employee_info(EMP_ID), CITY varchar2(15), STATE varchar2(15), COUNTRY varchar2(15), ZIP_CODE varchar2(15));
desc emp_address_details;
insert into emp_address_details values (101, 10, 'Vegas', 'LONDON', 'UK', '88901');
insert into emp_address_details values (102, 20, 'Carson', 'NEVADA', 'US', '90220');
commit;

select * from employee_info;
select * from emp_address_details;

set serveroutput on;
Create or replace function Get_Employee_Address(v_emp_id IN number)
return varchar2
as
v_address varchar2(1000);
Begin
    select 'Name is '||e.FIRST_NAME||' '||e.LAST_NAME||' '||'And Address is '||a.EMP_ADDRESS_ID||' '|| a.CITY||' '||a.STATE||' '||a.COUNTRY||' '||a.ZIP_CODE 
    into v_address
    from employee_info e, emp_address_details a where e.EMP_ID=v_emp_id and a.EMP_ID=e.EMP_ID;
    return v_address;
End;

select EMP_ID, FIRST_NAME, Get_Employee_Address(EMP_ID) ADDRESS from employee_info;
